#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{url} 
\usepackage{slashed}
\end_preamble
\use_default_options false
\maintain_unincluded_children no
\language english
\language_package default
\inputencoding utf8
\fontencoding auto
\font_roman "times" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\listings_params "basicstyle={\ttfamily},basewidth={0.45em}"
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Title
Diary - Part Ten-F
\end_layout

\begin_layout Date
October 2025 – present
\end_layout

\begin_layout Author
Linas Vepštas
\end_layout

\begin_layout Abstract
Unlike parts one through nine in this series,
 this one is not really about the language–learning effort.
 It is instead a private diary;
 a continuation of Part Ten–E,
 which got over–long.
 It is not curated for human consumption;
 I am making the assumption that no human being will ever actually read this.
 Thus,
 it is filled with random stuff I feel like writing.
 Some of it is very personal,
 some of it is nonsense.
 Mostly,
 I am finding that the act of writing helps otherwise vague and scattered thoughts quantum–collapse into a more coherent form,
 where I can examine them,
 like a dead butterfly pinned down in a display case.
 Dead words.
\end_layout

\begin_layout Abstract
If you are interested in this content,
 then you should ask an AI agent to read it,
 then pretended that it's me,
 then ask about it.
 I believe that present–day LLM technology is sufficiently advanced to be able to do this.
 
\end_layout

\begin_layout Section*
Introduction
\end_layout

\begin_layout Standard
Part Ten already got an introduction.
 A different way of thinking is about what is going on here is that this is a form of life–logging.
 Or,
 in 18th century terms,
 a diary.
 Just not anywhere near as compelling as those written by the famous diarists.
 This one is more of a mental self–portrait.
 And not even for you but for myself.
 Not to cast a narcissistic gaze at my own words,
 but to organize my own thoughts.
 Still in the experimental stage.
\end_layout

\begin_layout Subsection*
23 October 2025
\end_layout

\begin_layout Standard
I posted a long reply to bluesky that I rather like,
 so I am copying it here.
\end_layout

\begin_layout Standard
Fleeky
\end_layout

\begin_layout Standard
@fleeky.bsky.social
\end_layout

\begin_layout Standard
· 3h
\end_layout

\begin_layout Standard
@linas.org
\end_layout

\begin_layout Standard
apologies for being subjected to my shower thoughts ,
 has anyone tried to do physics sims with atomspace ala gravitas method that wolfram alpha tried ?
 
\end_layout

\begin_layout Standard
wolframinstitute.org/output/compu...
\end_layout

\begin_layout Standard
i *may* have already asked you this ,
 apologies for any memory loss (it's accelarating)
\end_layout

\begin_layout Standard
Computational General Relativity in the Wolfram Language using Gravitas I:
 Symbolic and Analytic Computation —
 Wolfram Institute
\end_layout

\begin_layout Standard
Jonathan Gorard Gravitas introduces a robust computational framework for general relativity in the Wolfram Language,
 featuring seamless integration of symbolic and numerical tools to handle complex ...
\end_layout

\begin_layout Standard
wolframinstitute.org
\end_layout

\begin_layout Standard
Linas Vepstas
\end_layout

\begin_layout Standard
@linas.org
\end_layout

\begin_layout Standard
· 1h
\end_layout

\begin_layout Standard
No one has tried.
 But its a good question.
 I want to tell you what I want to do with the Atomspace for this kind of stuff,
 and also a guess at what wolfram is actually doing.
 Perhaps a guess a about wolfram,
 first.
\end_layout

\begin_layout Standard
Linas Vepstas
\end_layout

\begin_layout Standard
@linas.org
\end_layout

\begin_layout Standard
· 1h
\end_layout

\begin_layout Standard
So,
 there's a giant industry for solving diffeqs.
 The most famous of these are weather prediction,
 and then fluid dynamics for wings,
 boats,
 sails,
 jet engines,
 rocket exhaust,
 and them mechanical stress,
 vibration,
 safety.
 Some run on supercomputers,
 others on ordinary PCs.
\end_layout

\begin_layout Standard
Linas Vepstas
\end_layout

\begin_layout Standard
@linas.org
\end_layout

\begin_layout Standard
· 1h
\end_layout

\begin_layout Standard
Solving GR equations is a very special case.
 Due to history,
 this is usually runs on supercomputers,
 FORTRAN code written by grad students of the decades.
 My grad school office-mate was blowing up supernova on Los Alamos machines.
 So,
 atomic bombs,
 but much much bigger.
\end_layout

\begin_layout Standard
Linas Vepstas
\end_layout

\begin_layout Standard
@linas.org
\end_layout

\begin_layout Standard
· 57m
\end_layout

\begin_layout Standard
The gravitational wave search code will also be running on supercomputers with gobs of GPU's on each node,
 using code that has been tuned,
 revised,
 rewritten,
 again and again over the decades.
 Works great,
 if you have the money,
 the NSF grants needed to get supercomputer access.
 But ...
\end_layout

\begin_layout Standard
Linas Vepstas
\end_layout

\begin_layout Standard
@linas.org
\end_layout

\begin_layout Standard
· 55m
\end_layout

\begin_layout Standard
What happens if you're a starting grad student and your thesis advisor is a shmuck with no grants,
 and you want to dabble in this?
 Wolfram is providing a rather awesomely appetizing solution:
 something you can mess with easily and at low cost.
\end_layout

\begin_layout Standard
Linas Vepstas
\end_layout

\begin_layout Standard
@linas.org
\end_layout

\begin_layout Standard
· 52m
\end_layout

\begin_layout Standard
I assume Wolfram's code is written by an LLM,
 Claude or ChatGPT,
 so trained on that supercomputer code,
 "likely to be correct".
 I assume its overseen by a "professional software engineer" (grad students and their profs write amazingly shitty code.
 Paying a real developer works wonders.)
\end_layout

\begin_layout Standard
Linas Vepstas
\end_layout

\begin_layout Standard
@linas.org
\end_layout

\begin_layout Standard
· 50m
\end_layout

\begin_layout Standard
So,
 having some professionally-written GR-solving code that runs on your laptop,
 and/or some mid-range monster machine you can afford,
 integrated with the rest of the wolfram stack...
 this is a winner.
 All that's losing about it is it's not open source and is a walking GPL violation.
\end_layout

\begin_layout Standard
Linas Vepstas
\end_layout

\begin_layout Standard
@linas.org
\end_layout

\begin_layout Standard
· 42m
\end_layout

\begin_layout Standard
And now,
 for opencog.
 I'm interesting in something similar,
 but different.
 The starting point,
 for me,
 are concepts from proof theory.
 In proof theory,
 you have a collection of axioms,
 and a collection of inference rules.
 These have the form of "jigsaw pieces",
 and ...
\end_layout

\begin_layout Standard
Linas Vepstas
\end_layout

\begin_layout Standard
@linas.org
\end_layout

\begin_layout Standard
· 37m
\end_layout

\begin_layout Standard
By assembling and reassembling these,
 one can ..
 construct proofs ...
 simplify equations ...
 make inferences ...
 generate hypothesis ...
 solve constraint problems ...
 optimize solutions ...
 This is a vast collection of comp-sci tasks for which there are thousands of very custom algos for solving.
\end_layout

\begin_layout Standard
Linas Vepstas
\end_layout

\begin_layout Standard
@linas.org
\end_layout

\begin_layout Standard
· 32m
\end_layout

\begin_layout Standard
I want to unify these into a general framework.
 e.g.
 there are many constraint solvers;
 my favorite is the UPotsdam ASP solver.
 There are many theorem provers,
 I have no favorite.
 For general symbolc algebra systems,
 we have wolfram and symbolica,
 octave,
 maxima,
 sympy,
 ....
\end_layout

\begin_layout Standard
Linas Vepstas
\end_layout

\begin_layout Standard
@linas.org
\end_layout

\begin_layout Standard
· 30m
\end_layout

\begin_layout Standard
Examples of optimizers include the internals of gcc and clang:
 systems that take algebraic expressions (written in C/C++/Java),
 compile them into some intermediate language,
 optimize,
 then compile to assembly or bytecode or JIT.
\end_layout

\begin_layout Standard
Linas Vepstas
\end_layout

\begin_layout Standard
@linas.org
\end_layout

\begin_layout Standard
But you could never use compiler internals to "prove math theorems in general",
 and maybe in principle you could use a theorem provide to implement a compiler it would be dog-shit slow.
 Neither replaces maxima/symbolic/whatever.
 None are as fast as a SAT solver.
\end_layout

\begin_layout Standard
October 23,
 2025 at 5:25 PM
\end_layout

\begin_layout Standard
Linas Vepstas
\end_layout

\begin_layout Standard
@linas.org
\end_layout

\begin_layout Standard
· 25m
\end_layout

\begin_layout Standard
So I'm interested in the generic problem of assembling jigsaw pieces.
 Which,
 BTW,
 is called "parsing" and "generation" in traditional comp sci.
 Which,
 unfortunately,
 obscures the depth of breadth of what "parsing" or "generation" actually are.
 Those two words erect a mental prison.
\end_layout

\begin_layout Standard
Linas Vepstas
\end_layout

\begin_layout Standard
@linas.org
\end_layout

\begin_layout Standard
· 21m
\end_layout

\begin_layout Standard
Getting back to general relativity:
 there is one more step,
 taken by Przemysław Prusinkiewiwcz,
 in "Algorithmic Botany".
 He takes cellular automata (think "DNA") and couples them to diff-eq (think "biochemical reactions") and low and behold,
 can explain "most of" botany.
\end_layout

\begin_layout Standard
Linas Vepstas
\end_layout

\begin_layout Standard
@linas.org
\end_layout

\begin_layout Standard
· 18m
\end_layout

\begin_layout Standard
It's the most utterly remarkable work I've ever seen,
 I'm not sure why he doesn't have a Nobel Prize.
 To me,
 it feels like its foundational for the so-called "neuro-symbolic computing" that is all the rage these days.
 Except the DL/NN folks don't give two figs for botany,
 so ...
 well,
 you know.
\end_layout

\begin_layout Standard
Linas Vepstas
\end_layout

\begin_layout Standard
@linas.org
\end_layout

\begin_layout Standard
· 14m
\end_layout

\begin_layout Standard
Side remark:
 the Michael Levin stuff about embedded cognition:
 they way I think about it is that one has these "jigsaws" floating around in a medium,
 e.g.
 enzymes.
 Or DNA.
 Or perhaps very abstractly:
 cell walls,
 or larger organs,
 growths,
 limbs.
 And these jigsaws self-assemble.
\end_layout

\begin_layout Standard
Linas Vepstas
\end_layout

\begin_layout Standard
@linas.org
\end_layout

\begin_layout Standard
· 10m
\end_layout

\begin_layout Standard
So I want my jigsaws to self-assemble also.
 But abstractly.
 My jigsaws can be axioms and inference rules.
 Or they can be 3D biochemical molecules.
 Or they can be immunoglobulin.
 Or a mycelial mat.
 Or ...
 optimization problems from economics (the barley and malt optimization problem from brewing.)
\end_layout

\begin_layout Standard
Linas Vepstas
\end_layout

\begin_layout Standard
@linas.org
\end_layout

\begin_layout Standard
· 7m
\end_layout

\begin_layout Standard
I don't care ..
 all these problems fall into the same class,
 all can be ruled by a generic theory.
 Fast algorithms in one problem domain can be homotopically transformed into fast algorithms in other problem domains.
 And we've got enough homotopy type theory with which to do this ...
\end_layout

\begin_layout Standard
Linas Vepstas
\end_layout

\begin_layout Standard
@linas.org
\end_layout

\begin_layout Standard
· 4m
\end_layout

\begin_layout Standard
But building the actual infrastructure to do this:
 sheesh.
 It's damn near impossible.
 I'm like ...
 boiling the ocean.
 No one nowhere has any kind of generic,
 general purpose codes for any of this.
 So I'm hand-sculpting it with a pocket knife from a piece of balsa wood...
 Oof.
 What else can I do?
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section*
The End
\end_layout

\begin_layout Standard
This is the end of Part Ten–F of the diary.
\end_layout

\end_body
\end_document
